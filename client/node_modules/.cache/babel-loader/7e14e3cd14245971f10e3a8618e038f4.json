{"ast":null,"code":"'use strict';\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\n\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\n\n\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var type;\n\n  try {\n    type = typeof source[methodName];\n  } catch (error) {// NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n  /* eslint no-loop-func:0 */\n\n\n  wrapper[methodName] = function () {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\n\n\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n  var difference = new Set();\n  list1.forEach(function (item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n  return difference;\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\n\n\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set ? Array.from(list.values()) : list;\n  return listArray.reduce(function (flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n/**\n * Guess the browser.\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\n\n\nfunction guessBrowser() {\n  if (typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string') {\n    if (/Chrome/.test(navigator.userAgent)) {\n      return 'chrome';\n    }\n\n    if (/Firefox/.test(navigator.userAgent)) {\n      return 'firefox';\n    }\n\n    if (/Safari/.test(navigator.userAgent)) {\n      return 'safari';\n    }\n  }\n\n  return null;\n}\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\n\n\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function () {\n      return currentListener;\n    },\n    set: function (newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\n\n\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function (result) {\n      onSuccess(result);\n    }, function (error) {\n      onFailure(error);\n    });\n  }\n\n  return promise;\n}\n/**\n * Make a unique ID.\n * @return {string}\n */\n\n\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\n\n\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function (propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\n\n\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n    target.addEventListener(propertyName.slice(2), function () {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function () {\n      return target[propertyName];\n    }\n  });\n}\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;","map":{"version":3,"sources":["/Users/chris/Desktop/call-me/client/node_modules/@twilio/webrtc/lib/util/index.js"],"names":["defer","deferred","promise","Promise","resolve","reject","delegateMethod","source","wrapper","target","methodName","match","type","error","apply","arguments","delegateMethods","difference","list1","list2","Array","isArray","Set","values","forEach","item","has","add","flatMap","list","mapFn","listArray","Map","from","reduce","flattened","mapped","concat","guessBrowser","navigator","userAgent","test","interceptEvent","currentListener","Object","defineProperty","get","set","newListener","removeEventListener","addEventListener","legacyPromise","onSuccess","onFailure","then","result","makeUUID","replace","c","r","Math","random","v","toString","proxyProperties","getOwnPropertyNames","propertyName","proxyProperty","value","writable","slice","dispatchEvent","enumerable","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Create a {@link Deferred}.\n * @returns {Deferred}\n */\nfunction defer() {\n  var deferred = {};\n  deferred.promise = new Promise(function(resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n}\n\n/**\n * Copy a method from a `source` prototype onto a `wrapper` prototype. Invoking\n * the method on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} methodName\n * @returns {undefined}\n */\nfunction delegateMethod(source, wrapper, target, methodName) {\n  if (methodName in wrapper) {\n    // Skip any methods already set.\n    return;\n  } else if (methodName.match(/^on[a-z]+$/)) {\n    // Skip EventHandlers (these are handled in the constructor).\n    return;\n  }\n\n  var type;\n  try {\n    type = typeof source[methodName];\n  } catch (error) {\n    // NOTE(mroberts): Attempting to check the type of non-function members\n    // on the prototype throws an error for some types.\n  }\n\n  if (type !== 'function') {\n    // Skip non-function members.\n    return;\n  }\n\n  /* eslint no-loop-func:0 */\n  wrapper[methodName] = function() {\n    return this[target][methodName].apply(this[target], arguments);\n  };\n}\n\n/**\n * Copy methods from a `source` prototype onto a `wrapper` prototype. Invoking\n * the methods on the `wrapper` prototype will invoke the corresponding method\n * on an instance accessed by `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction delegateMethods(source, wrapper, target) {\n  for (var methodName in source) {\n    delegateMethod(source, wrapper, target, methodName);\n  }\n}\n\n/**\n * Finds the items in list1 that are not in list2.\n * @param {Array<*>|Map<*>|Set<*>} list1\n * @param {Array<*>|Map<*>|Set<*>} list2\n * @returns {Set}\n */\nfunction difference(list1, list2) {\n  list1 = Array.isArray(list1) ? new Set(list1) : new Set(list1.values());\n  list2 = Array.isArray(list2) ? new Set(list2) : new Set(list2.values());\n\n  var difference = new Set();\n\n  list1.forEach(function(item) {\n    if (!list2.has(item)) {\n      difference.add(item);\n    }\n  });\n\n  return difference;\n}\n\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} mapFn\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n  var listArray = list instanceof Map || list instanceof Set\n    ? Array.from(list.values())\n    : list;\n\n  return listArray.reduce(function(flattened, item) {\n    var mapped = mapFn(item);\n    return flattened.concat(mapped);\n  }, []);\n}\n\n/**\n * Guess the browser.\n * @returns {?string} browser - \"chrome\", \"firefox\", \"safari\", or null\n */\nfunction guessBrowser() {\n  if (typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string') {\n    if (/Chrome/.test(navigator.userAgent)) {\n      return 'chrome';\n    }\n    if (/Firefox/.test(navigator.userAgent)) {\n      return 'firefox';\n    }\n    if (/Safari/.test(navigator.userAgent)) {\n      return 'safari';\n    }\n  }\n  return null;\n}\n\n/**\n * Intercept an event that might otherwise be proxied on an EventTarget.\n * @param {EventTarget} target\n * @param {string} type\n * @returns {void}\n */\nfunction interceptEvent(target, type) {\n  var currentListener = null;\n  Object.defineProperty(target, 'on' + type, {\n    get: function() {\n      return currentListener;\n    },\n    set: function(newListener) {\n      if (currentListener) {\n        this.removeEventListener(type, currentListener);\n      }\n\n      if (typeof newListener === 'function') {\n        currentListener = newListener;\n        this.addEventListener(type, currentListener);\n      } else {\n        currentListener = null;\n      }\n    }\n  });\n}\n\n/**\n * This is a function for turning a Promise into the kind referenced in the\n * Legacy Interface Extensions section of the WebRTC spec.\n * @param {Promise<*>} promise\n * @param {function<*>} onSuccess\n * @param {function<Error>} onFailure\n * @returns {Promise<undefined>}\n */\nfunction legacyPromise(promise, onSuccess, onFailure) {\n  if (onSuccess) {\n    return promise.then(function(result) {\n      onSuccess(result);\n    }, function(error) {\n      onFailure(error);\n    });\n  }\n  return promise;\n}\n\n/**\n * Make a unique ID.\n * @return {string}\n */\nfunction makeUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * For each property name on the `source` prototype, add getters and/or setters\n * to `wrapper` that proxy to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @returns {undefined}\n */\nfunction proxyProperties(source, wrapper, target) {\n  Object.getOwnPropertyNames(source).forEach(function(propertyName) {\n    proxyProperty(source, wrapper, target, propertyName);\n  });\n}\n\n/**\n * For the property name on the `source` prototype, add a getter and/or setter\n * to `wrapper` that proxies to `target`.\n * @param {object} source\n * @param {object} wrapper\n * @param {string} target\n * @param {string} propertyName\n * @returns {undefined}\n */\nfunction proxyProperty(source, wrapper, target, propertyName) {\n  if (propertyName in wrapper) {\n    // Skip any properties already set.\n    return;\n  } else if (propertyName.match(/^on[a-z]+$/)) {\n    Object.defineProperty(wrapper, propertyName, {\n      value: null,\n      writable: true\n    });\n\n    target.addEventListener(propertyName.slice(2), function() {\n      wrapper.dispatchEvent.apply(wrapper, arguments);\n    });\n\n    return;\n  }\n\n  Object.defineProperty(wrapper, propertyName, {\n    enumerable: true,\n    get: function() {\n      return target[propertyName];\n    }\n  });\n}\n\n/**\n * @typedef {object} Deferred\n * @property {Promise} promise\n * @property {function} reject\n * @property {function} resolve\n */\n\nexports.defer = defer;\nexports.delegateMethods = delegateMethods;\nexports.difference = difference;\nexports.flatMap = flatMap;\nexports.guessBrowser = guessBrowser;\nexports.interceptEvent = interceptEvent;\nexports.legacyPromise = legacyPromise;\nexports.makeUUID = makeUUID;\nexports.proxyProperties = proxyProperties;\n"]},"metadata":{},"sourceType":"script"}